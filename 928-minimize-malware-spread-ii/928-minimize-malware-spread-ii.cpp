class Solution {
public:
    vector<int> parent;
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        for(int i = 0;i<n;i++)  parent.push_back(i);
        //For non malware nodes
        vector<int> clean;
        set<int> initial_set(initial.begin(), initial.end());
        for(int i=0;i<n;i++)
            if(!initial_set.count(i)) clean.push_back(i);
        for(auto i: clean) {
            for(auto j: clean) {
                if(i != j && graph[i][j])
                    uni(i,j);
            }
        }
        // Size of each group
        vector<int> area(n,0);
        for(auto i: clean){
            area[find(i)]++;
        }
        unordered_map<int, set<int>> infected_nodes;
        unordered_map<int, int> infect_count;
        for(auto i: initial) {
            for( auto j: clean){
                if(graph[i][j])
                    infected_nodes[i].insert(find(j));
            }
            for(auto j: infected_nodes[i])
                infect_count[j]++;
        }
        // Try remove each malware
        int res = initial[0], max_cnt = -1;
        for(auto& [malware, nodes]: infected_nodes) {
            int count = 0;
            for(auto node: nodes){
                if(infect_count[node] == 1){
                    count += area[node];
                }
            }
            if(count > max_cnt || (count >= max_cnt && malware < res)){
                res = malware;
                max_cnt = count;
            }
        }
        return res;
    }
    int find(int x) {
        if(x != parent[x])
            parent[x] = find(parent[x]);
        return parent[x];
    }
    void uni(int x, int y){
        parent[find(x)] = find(y);
    }
};